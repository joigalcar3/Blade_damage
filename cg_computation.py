# Modules to import
from math import radians, cos, sin
from helper_func import *
from Propeller import Propeller


# User input
percentage_broken_blade_length = 20  # [%]
angle_first_blade = 0  # [deg]
state_blades = [1, 1, 1]  # switches [-]: 1 means that it is healthy
n_blade_segment = 50    # [-]
number_samples = 500    # [-]
degree_cla = 2          # [-]
degree_cda = 2          # [-]
start_cla_plot = -10     # [deg]
finish_cla_plot = 30    # [deg]
min_w = -2              # [m/s]
max_w = -0.5            # [m/s]
va = 3                  # [m/s]
coefficients_identification = True  # Whether the coefficients need to be identified
activate_params_blade_contribution_plotting = False  # Plot that shows how each blade section contributes to the coeffs
LS_method = "GLS"       # the type of least squares used for the identification of the drag and lift coefficients
n_rot_steps = 10        # The number of propeller positions used for taking the average
activate_avg_rot = True  # Switch to activate whether the instantaneous propeller state is used or the rotation average
optimization_method = 'min'   # Whether the opt. method should be Least Squares ("LS") or a scipy.minimization ("min")
min_method = "trust-constr"   # Nonlinear optimization method used to minimize Ax-b: Nelder-Mead, COBYLA
switch_constrains = True    # Whether the optimization should be constrained. Only for COBYLA, SLSQP and trust-constr

# Only for COBYLA, SLSQP and trust-constr accept constraints. Equality constraint means that the constraint function
# result is to be zero whereas inequality means that it is to be non-negative.
# SLSQP: Minimize a scalar function of one or more variables using Sequential Least Squares Programming
# trust-constr: Minimize a scalar function subject to constraints.
# COBYLA: Minimize a scalar function of one or more variables using the Constrained Optimization BY Linear Approximation
# algorithm. It only supports inequality constraints.

# Propeller info
propeller_mass_g = 5.07
propeller_mass = propeller_mass_g/1000  # [kg] measured 5.17
blade_mass_g = 1.11
n_blades = 3  # [-] measured 3
percentage_hub_m = (propeller_mass_g-blade_mass_g*n_blades)/propeller_mass_g*100  # [%]
tip_chord = 0.008  # [m] measured 0.008
largest_chord_length = 0.02  # [m] measured 0.02
second_segment_length = 0.032  # [m] measured 0.032
base_chord = 0.013  # [m] measured 0.013
length_blade_origin = 0.075  # [m] measured 0.076
radius_hub = 0.011  # [m] measured 0.012
start_twist = 27  # [deg] measured 26.39 [deg]
finish_twist = 5  # [deg] measured 4.46 [deg]

chord_lengths_rt_lst = [base_chord, largest_chord_length, tip_chord]
first_segment_length = length_blade_origin - radius_hub - second_segment_length
length_trapezoids_rt_lst = [first_segment_length, second_segment_length]

# Information about the drone state
body_velocity = np.array([[0, 0, 0]]).T
pqr = np.array([[0, 0, 0]]).T
attitude = np.array([[0, 0, 0]]).T
omega = 1256          # [rad/s]

# Check that the number of states equals the number of blades
if len(state_blades) != n_blades:
    raise Exception("The number of states does not equal the number of blades.")


# Compute the location of the center of gravity of the propeller
propeller = Propeller(0, n_blades, chord_lengths_rt_lst, length_trapezoids_rt_lst, radius_hub, propeller_mass,
                      percentage_hub_m, state_blades, angle_first_blade, start_twist, finish_twist,
                      broken_percentage=percentage_broken_blade_length, plot_chords_twist=False)
propeller.create_blades()
# cg_location = propeller.compute_cg_location()
# average_chords, segment_chords = compute_average_chords(chord_lengths_rt_lst, length_trapezoids_rt_lst, n_blade_segment)
# print(average_chords)
#
# # Compute the forces and moments generated by the shift in the center of gravity
# omega_local = 500
# time = 1
# dt = 0.001
# n_points = int(time/dt + 1)
# F_lst = np.zeros((3, n_points))
# M_lst = np.zeros((3, n_points))
# rotation_angle_lst = np.zeros(n_points)
# rotation_angle = 0
# for i in range(n_points):
#     F, M = propeller.compute_cg_forces_moments(omega_local, attitude)
#     F_lst[:, i] = F.flatten()
#     M_lst[:, i] = M.flatten()
#     rotation_angle_lst[i] = rotation_angle
#     rotation_angle = propeller.update_rotation_angle(omega_local, dt)
# plot_FM(np.arange(0, time+dt, dt), rotation_angle_lst, F_lst, M_lst)
#
# # Compute the lift/thrust generated by the propeller
# T, N = propeller.compute_lift_torque_matlab(body_velocity, pqr, omega)
# print(T)

# Compute the cl-alpha curve polynomial coefficients
if coefficients_identification:

    if not activate_avg_rot:
        coeffs, A, b = propeller.compute_cla_coeffs(number_samples, n_blade_segment, degree_cla, degree_cda,
                                                    min_w=min_w, max_w=max_w, va=va, rho=1.225, activate_plotting=True,
                                                    activate_params_blade_contribution_plotting=
                                                    activate_params_blade_contribution_plotting,
                                                    LS_method=LS_method, start_plot=start_cla_plot,
                                                    finish_plot=finish_cla_plot, optimization_method=optimization_method,
                                                    min_method=min_method, switch_constrains=switch_constrains)
    else:
        coeffs, A, b = propeller.compute_cla_coeffs_avg_rot(number_samples, n_blade_segment, degree_cla, degree_cda,
                                                            min_w=min_w, max_w=max_w, va=va, rho=1.225,
                                                            activate_plotting=True,
                                                            activate_params_blade_contribution_plotting=
                                                            activate_params_blade_contribution_plotting,
                                                            LS_method=LS_method, start_plot=start_cla_plot,
                                                            finish_plot=finish_cla_plot, n_rot_steps=n_rot_steps,
                                                            optimization_method=optimization_method,
                                                            min_method=min_method, switch_constrains=switch_constrains)
    cla_coeffs = coeffs[:degree_cla + 1, 0]
    cda_coeffs = coeffs[degree_cla + 1:, 0]
    print(cla_coeffs)
    print(cda_coeffs)

# Compute the thrust, thrust moment, x-y in plane force and torque
cla_coeffs = np.array([-4.65298061,   187.59293314, -1413.02494156,  3892.87107255, -4410.25625439,  1744.50538986])
cda_coeffs = np.array([-1.66217226e+00, -6.65648057e+01,  7.26049638e+02, -1.84544413e+03, 1.06106349e+03,  4.11807861e+02])
omega = 1256          # [rad/s]
propeller_speed = np.array([[np.sqrt(24)], [0], [-1]])
T_remaining, T_damaged, M_remaining, M_damaged = propeller.compute_thrust_moment(n_blade_segment, omega,
                                                                                 propeller_speed, cla_coeffs,
                                                                                 cda_coeffs)
Q_remaining, Q_damaged, F_remaining, F_damaged = propeller.compute_torque_force(n_blade_segment, omega, propeller_speed,
                                                                                cla_coeffs, cda_coeffs)
print(T_remaining, T_damaged, M_remaining, M_damaged)
print(Q_remaining, Q_damaged, F_remaining, F_damaged)

# Put all the forces and moments together
propeller.set_rotation_angle(0)
cla_coeffs = np.array([-5.89,   251.29, -1919.48,  5298.43, -5990.51,  2364.58])
cda_coeffs = np.array([-1.39, -119.59,  1348.14, -4142.33, 4331.41,  -1157.51])
omega_local = 500       # [rad/s]
time = 1
dt = 0.001
n_points = int(time/dt + 1)
F_lst = np.zeros((3, n_points))
M_lst = np.zeros((3, n_points))
rotation_angle_lst = np.zeros(n_points)
rotation_angle = 0
for i in range(n_points):
    if not i % 10:
        print(f'Iteration {i} out of {n_points-1}')
    F = np.zeros((3, 1))
    M = np.zeros((3, 1))

    # Computation of forces and moments that derive from the change in mass
    F_cg, M_cg = propeller.compute_cg_forces_moments(omega_local, attitude)
    F += F_cg
    M += M_cg

    # Computation of moments and forces derived from the loss in an aerodynamic surface
    T_remaining, T_damaged, M_remaining, M_damaged = propeller.compute_thrust_moment(n_blade_segment, omega_local,
                                                                                     propeller_speed, cla_coeffs,
                                                                                     cda_coeffs)
    Q_remaining, Q_damaged, F_remaining, F_damaged = propeller.compute_torque_force(n_blade_segment, omega_local,
                                                                                    propeller_speed, cla_coeffs,
                                                                                    cda_coeffs)
    F[2, 0] -= T_damaged
    M -= M_damaged.T
    M[2, 0] -= Q_damaged
    F -= F_damaged.T

    F_lst[:, i] = F.flatten()
    M_lst[:, i] = M.flatten()
    rotation_angle_lst[i] = rotation_angle
    rotation_angle = propeller.update_rotation_angle(omega_local, dt)

# Plot the forces and moments
plot_FM(np.arange(0, time+dt, dt), rotation_angle_lst, F_lst, M_lst)
print("hola")



